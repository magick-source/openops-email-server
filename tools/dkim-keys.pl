#!/usr/bin/perl -w

use strict;
use v5.18;

#TODO(maybe): add support for multiple signatures per domain.
#TODO(maybe): move dns check in 'check-domains.pl' into a lib
#             and also use it here!

use Net::DNS;
use Config::Tiny;
use Getopt::Long;
use Term::ANSIColor qw(colored);

my $check     = undef;
my $create    = undef;
my $activate  = undef;
my $show      = undef;

my $domain    = undef;
my $selector  = undef;

my $verbose   = 0;
my $help      = 0;

init();
$help = 1 unless $domain;

if ( $help ) {
  help();
  exit 0;
}

$check=1  unless $activate or $create or $show;

$selector ||= $create ? _make_selector( $domain ) : _find_selector( $domain );

create_key( $domain, $selector ) if $create;
activate_key( $domain, $selector ) if $activate;

check_domain( $domain, $selector ) if $check;
show_pubkey( $domain, $selector ) if $show;

print STDERR "\n\n";
exit 0; #just to make it clear ;-)

sub check_domain {
  info(GROUP => "Checking $domain -> $selector");

  my $keyinfo = _load_keytable( $domain, $selector );
  if ( $keyinfo ) {
    info( OK => "key for $domain/$selector was found" );
  } else {
    info( ERROR => "Key for $domain/$selector is missing");
    info( INFO  => "You can create it with: \n"
                  ."\t $0 -d $domain -s $selector --create" );

    return;
  }

  # Is the key active?
  my $key = _load_signingtable( $domain );
  unless ( $key ) {
    info( ERROR => "There is no active key for '$domain'");
    return;
  }

  if ( $key eq $keyinfo->{keyname} ) {
    info( OK => "key '$selector' is active/default for '$domain'");

  } else {
    my ($active) = $key =~ m{\A([^\.]+)\.};
    info( ERROR => "Currently active key is '$active' - not '$selector'");

    return;
  }

  info( INFO => "use 'check-domains.pl' to further check the config");

  return;
}

sub create_key {
  my ($domain, $selector) = @_;

  my $fname = "/etc/opendkim/keys/$domain/$selector.txt";
  if ( -f $fname ) {
    my $keyinfo = _load_keytable( $domain, $selector );
    if ($keyinfo) {
      info( ERROR => "Key already exists and is known. only showing it");
      # showing pubkey is always done when creating
    } else {
      info( ERROR => "Key exists, but is not registered - registering");
      _register_key( $domain, $selector );
    }
  } else { 
    _generate_opendkim_key( $domain, $selector );
    _register_key( $domain, $selector );
  }

  show_pubkey( $domain, $selector );
}

sub _generate_opendkim_key {
  my ($domain, $selector) = @_;

  my $dir = "/etc/opendkim/keys/$domain";
  unless ( -d $dir ) {
    mkdir $dir;
  }
  
  info(GROUP => "Generating opendkim key for '$domain'/'$selector'");
  my $out = qx{/usr/bin/opendkim-genkey -b 2048 -d '$domain' -D '$dir' -s '$selector' -v 2>&1 };
  print STDERR $out,"\n\n" if $verbose;

  my (undef, undef, $uid, $gid) = getpwnam('opendkim');
  chown $uid, 0, "$dir/$selector.private";

  return;
}

sub _register_key {
  my ($domain, $selector) = @_;

  open my $fh, '>>', "/etc/opendkim/KeyTable"
    or die "Error appending KeyTable: $!";

  print $fh "\n$selector._domainkey.$domain $domain:$selector:/etc/opendkim/keys/$domain/$selector.private\n";

  close $fh;
  my $key = _load_keytable($domain, $selector, 1); # force keytable reload

  return;
}

sub activate_key {
  my ($domain, $selector) = @_;

  my $active_key = _load_signingtable( $domain );
  my $new_key = "$selector._domainkey.$domain";

  my $key = _load_keytable( $domain, $selector );
  unless ( $key ) {
    info( ERROR => "key '$domain'/'$selector' is missing or unregistered");
    info( INFO  => "\tplease create/register it first");
    info( INFO  => "\tyou can use:\n\t$0 -d $domain -s $selector --create");
    return;
  }

  if ($active_key and $active_key eq $new_key) {
    info(OK => "'$selector' is already active for '$domain'");
    return;
  }

  info( GROUP => "Generating new SigningTable");

  my $table = _load_signingtable('--FOR-UPDATE--');
  $table->{$domain}->{"*\@$domain"} = $new_key;

  my $fname = '/etc/opendkim/SigningTable';
  open my $fh, '>', "$fname.new"
    or die "Error creating 'SigningTable.new': $!";

  print $fh "\n# *\@example.net mail._domainkey.example.net\n\n";

  for my $dom (sort keys %{$table}) {
    for my $pat (sort keys %{ $table->{$dom} }) {
      my $keyname = $table->{$dom}->{$pat};
      print $fh "$pat $keyname\n";
    }
  }
  my $date = _make_date(); 
  print $fh "\n\n# Generated by dkim-keys.pl at $date\n\n";
  close $fh;
  info( OK => "New SigningTable generated - switching with old one");

  rename( $fname, "$fname.old" );
  rename( "$fname.new", $fname);
  info( OK => "SigningTable switched - reloading dkim");

  my $out = qx{ /etc/init.d/opendkim reload };
  print STDERR "$out\n\n";

  info( OK => "'$domain'/'$selector' is now active" );
  return;
}

sub show_pubkey {
  my ($domain, $selector) = @_;

  info( GROUP => "Showing DNS Entry for $domain/$selector" );
  my $keyinfo = _load_keytable( $domain, $selector );
  unless ($keyinfo) {
    info( ERROR => "Key is missing in the KeyTable");
    return;
  }

  my $pubkey = _load_pubkey( $keyinfo );
  if ( $pubkey ) {
    return _print_pubkey( $domain, $selector, $pubkey );

  } else {
    info( ERROR => "Could not read the public key");
  }

}

sub _print_pubkey {
  my ($domain, $selector, $key) = @_;

  return unless $key;
 
  my $formed = '';
  my $size = 35;
  my $part = '';
  my $prefix = '';
  my $rest = $key;
  while ( $rest ) {
    ($part,$rest) = $rest =~ m<\A(.{1,$size})(.*)\z>;

    $formed .= "\n" if $formed;
    $formed .= qq{$prefix"$part"};

    unless ($prefix) {
      $size = 50;
      $prefix = "\t\t\t";
    }
  }

  print STDERR "$selector._domainkey\tIN\tTXT\t( $formed );\n\n";

  return;
}

sub _load_pubkey {
  my ($keyinfo) = @_;

  return unless $keyinfo;
  my $fname = $keyinfo->{keyfile};
  $fname =~ s{\.private\z}{.txt};

  return unless -f $fname;
  open my $fh, '<', $fname or die "Can't open file '$fname': $!";

  my $pubkey = '';
  while ( my $ln = <$fh> ) {
    next if $ln =~ m{\A\-\-};

    my (undef, $val) = split /"/, $ln;

    $pubkey .= $val;
  }

  return $pubkey;
}

sub _find_selector {
  my ($domain) = @_;

  my $key = _load_signingtable( $domain );
  if ( $key ) {
    my ($selector) = $key =~ m{\A([^\.]+)\.};
    return $selector if $selector;
  }
  
  return _make_selector( $domain );
}

sub _make_selector {
  my ($domain) = @_;

  my (undef,undef, undef, undef, $mon, $year) = localtime();

  $year+= 1900;
  $mon += 1;

  return "$year$mon";
}

sub _make_date {
  my (undef, $min, $hour, $day, $mon, $year) = localtime();
  $mon++;
  $year+=1900;

  return "$year/$mon/$day $hour:$min";
}

sub _load_keytable {
  my ($domain, $selector, $reload) = @_;

  state %keytable;

  %keytable = () if $reload;

  unless (keys %keytable) {
    my $fname = "/etc/opendkim/KeyTable";
    open my $fh, '<', $fname or die "Failed to open the KeyTable: $!";
    while (my $ln = <$fh>) {
      next if $ln =~ m{\A\s*\#};
      next if $ln =~ m{\A\s*\z};
      $ln =~ s{\#.*\z}{};
      $ln =~ s{\s*\z}{};

      my ($keyname,$keydef) = split /\s+/, $ln;
      next unless $keydef;
      my ($dom,$sel,$keyfile) = split /:/, $keydef;
      $keytable{ $dom }{ $sel } = {
          keyname   => $keyname,
          domain    => $dom,
          selector  => $sel,
          keyfile   => $keyfile,
        };
    }
  }

  return $keytable{ $domain }{ $selector }
    if $domain and $selector;

  return;
}

sub _load_signingtable {
  my ($domain, $reload) = @_;

  state %sign_table;
  %sign_table = () if $reload;

  unless (keys %sign_table) {
    my $fname = "/etc/opendkim/SigningTable";
    open my $fh, '<', $fname or die "Failed to open the SigningTable: $!";
    while (my $ln = <$fh>) {
      next if $ln =~ m{\A\s*\#};
      next if $ln =~ m{\A\s*\z};
      $ln =~ s{\#.*\z}{};

      my ($mask, $key) = split /\s+/, $ln;
      my (undef,$domain) = split /\@/, $mask;

      unless ($domain and $key) {
        print STDERR "don't know how to parse '$ln'\n\n";
        next;
      }

      $sign_table{ $domain }{ $mask } = $key; 
    }
  }

  return \%sign_table if $domain eq '--FOR-UPDATE--';

  return $sign_table{ $domain }{ "*\@$domain" };
}

sub help {
  print STDERR <<EoH;
$0 helps you manage dkim keys for opendkim.

Usage:

$0 --domain=<...> [other options]

Options:

  --domain=<...>    - domain to manage keys of.

  --selector=<...>  - the dns selector for the key.
        the default is the current month in format YYYYMM
          unless the only action selected is check, in which case
          the a check will be made to find if any key is
          properly set up.


possible actions [multiple can be used]:
  --check           - checks if the key exists, if it is active
                      and if DNS is set
                    If no action is passed, this is performed

  --create          - creates a new DKIM key.
                      the newly created key will be added to KeyTable.

  --activate        - activates a newly created or previously existing
                      DKIM key - this will change the SingingTable.

  --show            - prints the DNS entry to publish the pubkey for DKIM

Other:
  --verbose         - display the data checked [DNS, file paths, etc]

  --help            - display this screen and exit.

EoH

}

sub init {
  GetOptions(
    activate    => \$activate,
    check       => \$check,
    create      => \$create,
    show        => \$show,

    'domain=s'  => \$domain,
    'selector=s'=> \$selector,
    's=s'       => \$selector, #alias

    verbose     => \$verbose,
    help        => \$help,
  );
}

sub info {
  my ($type, $text) = @_;

  return unless -t STDERR;
  return if $type eq 'INFO' and !$verbose;

  my $color = {
    OK    => 'reset',
    ERROR => 'yellow',
    INFO  => 'cyan',
    GROUP => 'bold blue',
  }->{$type} || 'reset';

  my $prefix = {
    OK    => '* ',
    ERROR => '* ',
    INFO  => 'i: ',
    GROUP => '>> ',
  }->{$type} || '';

  my $suffix = {
    OK    => colored(['bold green'], ' [OK]'),
    ERROR => colored(['bold red'], ' {FAIL} '),
  }->{$type} || '';

  print STDERR "\n" if $type eq 'GROUP';
  print STDERR colored([$color], "$prefix$text$suffix"),"\n";
}

